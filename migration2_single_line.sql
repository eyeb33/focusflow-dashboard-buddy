CREATE TABLE IF NOT EXISTS lesson_states (id UUID PRIMARY KEY DEFAULT gen_random_uuid(), user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE, topic_id TEXT NOT NULL, subtopic TEXT NOT NULL, current_stage TEXT NOT NULL, prior_knowledge_level TEXT, mistakes_made JSONB DEFAULT '[]'::jsonb, checks_completed INTEGER DEFAULT 0, checks_total INTEGER DEFAULT 3, time_spent_seconds INTEGER DEFAULT 0, completed BOOLEAN DEFAULT false, started_at TIMESTAMPTZ DEFAULT NOW(), updated_at TIMESTAMPTZ DEFAULT NOW(), completed_at TIMESTAMPTZ); CREATE INDEX IF NOT EXISTS idx_lesson_states_user_topic ON lesson_states(user_id, topic_id, subtopic); CREATE INDEX IF NOT EXISTS idx_lesson_states_user_active ON lesson_states(user_id, completed) WHERE completed = false; ALTER TABLE lesson_states ENABLE ROW LEVEL SECURITY; DROP POLICY IF EXISTS "Users can view own lesson states" ON lesson_states; CREATE POLICY "Users can view own lesson states" ON lesson_states FOR SELECT USING (auth.uid() = user_id); DROP POLICY IF EXISTS "Users can create own lesson states" ON lesson_states; CREATE POLICY "Users can create own lesson states" ON lesson_states FOR INSERT WITH CHECK (auth.uid() = user_id); DROP POLICY IF EXISTS "Users can update own lesson states" ON lesson_states; CREATE POLICY "Users can update own lesson states" ON lesson_states FOR UPDATE USING (auth.uid() = user_id); DROP POLICY IF EXISTS "Users can delete own lesson states" ON lesson_states; CREATE POLICY "Users can delete own lesson states" ON lesson_states FOR DELETE USING (auth.uid() = user_id); CREATE OR REPLACE FUNCTION update_lesson_states_updated_at() RETURNS TRIGGER AS $$ BEGIN NEW.updated_at = NOW(); RETURN NEW; END; $$ LANGUAGE plpgsql; DROP TRIGGER IF EXISTS lesson_states_updated_at ON lesson_states; CREATE TRIGGER lesson_states_updated_at BEFORE UPDATE ON lesson_states FOR EACH ROW EXECUTE FUNCTION update_lesson_states_updated_at();